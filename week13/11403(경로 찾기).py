"""
'모든 정점 (i, j)', 그리고 '방향' 그래프라는 점이 핵심이다.
모든 점에서 다 시작해봐야할까? -> 그래도 될듯? -> 근데 굳이?
문제는, 자기 자신으로도 돌아올 수 있어야 한다는 것 -> 카운트를 2로 잡고, 한 번 다 돌았을 때 1이면 갈 수 있다는거고, 0이면 갔다올 수도 있다는 걸로 해야하나
하나의 점을 시작으로 돌아보자. 카운트가 2면 아직 한 번도 탐색 안됐다는 것. 1이면 탐색은 됐다는 것인데.. 이걸 어떻게 연결하지?
단계별로 생각해보자.

재귀로 해볼까?
어느 점에서 어느 점으로 연결이 된다면, 그 점에서 갈 수 있는 것들은 전부 포함할 수 있다는 이야기잖아. 그렇지? 돌아올 수 있다면 뭐 돌아올 수 있으면 되는거고. 그리고 그 시작점에서부터 경로 탐색이 시작중이라면 더이상 탐색하지 않아도 되는 것
자 재귀라고 생각하고 다시 짜보자.
1. 어느 점에서 탐색을 시작한다
2. 연결된 점이 있다면, 그 점 + 그 점에서 탐색할 수 있는 점들을 조합해서 자기랑 연결된 점에 다 추가한다.
종료 조건을 생각해보자.
1. 연결된 점이 없다.
2. 이미 탐색한 점이다.

이미 탐색한 점인지는 어떻게 알까? -> 해당 함수를 시작할 때 True
모든 점을 탐색할 때까지 진행. ㅇㅋ
문제점 : 탐색을 시작한 점에 돌아왔을 때 더이상 탐색을 할 수 없게 된다. searched[i]가 맞을까? 만약 시작점으로 돌아오는 경로를 찾았다면? 그 점도 시작점에서 갈 수 있는 모든 점들을 갈 수 있게 되는거잖아?
그렇게 하면 해결이 되나?
아니지. 타고 타고 가다보면, 시작점에 되어 있었던 애들 업데이트 되기 전에 ...
이건 다시 생각해봐야한다.
그냥 모든 점에서 탐색할까? 사실 그래도 나쁘진 않을 것 같은데 -> 나쁘다
재귀로 가는데, 재귀로 갈 때의 문제점을 해결해보자.
문제점 : 꼬리물기를 해결하려면 searched가 있긴 해야한다. -> 마지막 작업만 한 번 더 해주면 되지 않나?
각자 갈 수 있는 곳을 다 탐색은 하잖아? 그러면 내가 갈 수 있는 곳과 연결된 곳들을 다 업데이트
아 근데.. 그러면 문제가 생기긴 하네. 업데이트 순서가 중요하다.
먼저 탐색된 곳부터 업데이트 반영해줘야하는게 문제다. 탐색된 순서대로 큐를 관리해줘야하나? -> 아니다. 근본적인 해결책이 아니다.
재귀 안좋은 방법인 것 같다.
모든 경우의 수를 다 탐색해보는게 나을 것 같은데? 시간복잡도는?
정점의 개수 100개. 간선이 개수 다 있다고 쳤을 때 100 * 99 = 9900개
탐색의 경우의 수는? N**3밖에 안될 것 같은데 해보자.
searched[i] 가 True가 되는 시점은 
"""
N = int(input())
graph = [list(map(int, input().split())) for _ in range(N)]
results = [['0'] * N for _ in range(N)]

def search(i, result):
    next_nodes = [i for i, e in enumerate(graph[i]) if e]
    for next_node in next_nodes:
        if result[next_node] == '1':
            continue
        result[next_node] = '1'
        search(next_node, result)

for i in range(N):
    row = results[i]
    search(i, row)

print(*(' '.join(result) for result in results), sep='\n')