"""
자신의 '모든' 친구들이 얼리 어답터일 때만 아이디어를 받아들인다.
최소의 수의 얼리 어답터를 확보하는 것이 핵심
사이클이 존재하지 않는 경우만 고려. 
2 <= N 1,000,000개. 꽤 많다. 그러나 시간은 3초
이거 왠지 레드/블랙인가 그거랑 비슷한 느낌

룰을 생각해보자. 만약 자기 자신이 얼리어답터라면? 주위는 얼리어답터든 아니든 상관없다.
얼리어답터가 아니라면? 주위는 반드시 얼리어답터여야 한다.
필요한 최소 얼리 어답터를 구하는 것.
이걸 위상 정렬을 써서 해결하나? 아니다. 너비 우선 탐색을 해야할까? 백트래킹인가?
트리일 때, 자기 자신이 얼리어답터일 때와 아닐 때 두 경우 모두, 자신 포함 서브트리에서 가질 수 있는 최대의 수를 갖고 있다고 생각하면 될 것 같다.

트리를 어떻게 표현할지도 중요할 것 같다. -> 항상 순서대로 주어지려나? -> 그렇다고 생각하자. -> 아니다!
그러면 Leaf를 기억해뒀다가 올라가는 식으로 하면 될 거 같은데. Leaf는 어떻게 구하지?
Leaf에서 올라가지 말고, TOP에서 내려오자. 그리고 재귀식으로 하자. 어차피 재귀호출의 입장에서는 한 번 씩만 호출한다. 중복호출이 일어날 일이 없다. -> Root를 찾기는 힘들다. Leaf는 찾을 수 있나? 못찾는다. 이 방법은 생각하지 말자.
근데 이렇게 하려면 뭐가 자식이고 뭐가 부모인지 알아야 할 것 같은데, 그건 어떻게 하지? 그냥 자기랑 연결된 애들 다 찾나?
is_root를 어떻게 판별할 것인가. 그냥 단순히는 안될 것 같은데. 

현재로서는 부모와 자식을 구분하기가 힘들다. -> 그냥 그래프라고 생각하고 탐방하자. 그럼 재귀가 가장 편할 것 같다.
dp에 visited를 모두 포함해놓는거지
"""

import sys
sys.setrecursionlimit(10 ** 9)
input = lambda: sys.stdin.readline().rstrip()

N = int(input())
graph = [None] + [[] for _ in range(N)]
dp = [None for _ in range(N+1)]

for _ in range(N-1):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)
    
def dfs(i, p):
    dp[i] = [0, 0]
    for j in graph[i]:
        if j == p:
            continue
        dfs(j, i)
        dp[i][0] += min(dp[j])
        dp[i][1] += dp[j][0]
    dp[i][0] += 1
        
dfs(1, 0)
print(min(dp[1]))