"""
조건 1. 계속 증가해야한다.
조건 2. 합이 가장 커야한다.
아까랑 같은 방식으로 풀면 될 것 같은데?
자연수니까 좋네

잘못 생각했다. 띄어져 있어도 수열 판별하는구나

DP일 것 같다.
일단 꼭 가지고 있어야 하는 것이, 현재까지의 max + 가장 마지막 수 
모든 경우를 다 구할 수 있나? 있을 것 같은데. 탐색할 때마다 탐색. 불가능할 것 같지는 않다.
그래도 효율적인 방법이 있겠지
또 뭘 가지고 있어야 할까
자기보다 작은 수중에 가장 높은 합을 찾아야지. 그럼 뭘 업데이트 해줘야하지?
일단은 max_sum은 업데이트 해줘야지. 안될수도 있고. 아니라면 자기를 기록하긴 해야하고.
어라 A_i가 1 ~ 1000까지라고 되어있네?
오 이걸 이용해서 풀어보자.
"""

N = int(input())
A = tuple(map(int, input().split()))
max_sum = [0] * (1001)
for e in A:
    max_sum_under_e = max(max_sum[:e])
    max_sum[e] = max(max_sum[e], max_sum_under_e + e)
print(max(max_sum))